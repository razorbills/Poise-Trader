#!/usr/bin/env python3
"""
üè¶ MULTI-ASSET PORTFOLIO MANAGER
Elite portfolio management across multiple cryptocurrencies with AI optimization
"""

import numpy as np
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Set
from collections import deque, defaultdict
from dataclasses import dataclass, field
import logging
import json

logger = logging.getLogger(__name__)

@dataclass
class AssetAllocation:
    """Asset allocation information"""
    symbol: str
    target_weight: float
    current_weight: float
    risk_score: float
    momentum_score: float
    confidence: float
    last_updated: datetime = field(default_factory=datetime.now)

@dataclass
class PortfolioMetrics:
    """Portfolio performance metrics"""
    total_value: float
    daily_pnl: float
    win_rate: float
    sharpe_ratio: float
    max_drawdown: float
    volatility: float
    beta: float
    alpha: float

class MultiAssetPortfolioManager:
    """üè¶ Elite multi-asset portfolio management system"""
    
    def __init__(self, initial_capital: float = 5000.0, max_assets: int = 8):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.max_assets = max_assets
        
        # Portfolio composition
        self.asset_allocations = {}
        self.position_sizes = {}
        self.correlation_matrix = {}
        
        # Performance tracking
        self.portfolio_history = deque(maxlen=1000)
        self.rebalance_history = deque(maxlen=100)
        self.daily_returns = deque(maxlen=252)  # 1 year
        
        # Risk management
        self.portfolio_var = 0.0  # Value at Risk
        self.max_correlation = 0.7  # Max correlation between assets
        self.diversification_score = 0.0
        
        # AI components
        self.allocation_optimizer = AllocationOptimizer()
        self.risk_analyzer = PortfolioRiskAnalyzer()
        self.rebalancing_engine = SmartRebalancingEngine()
        
        # Active asset management
        self.active_symbols = set()\n        self.asset_performance = defaultdict(lambda: {'trades': [], 'metrics': {}})\n        self.cross_asset_signals = defaultdict(list)\n        \n        print(f\"üè¶ Multi-Asset Portfolio Manager initialized - Capital: ${initial_capital:,.2f}, Max Assets: {max_assets}\")\n    \n    async def add_asset(self, symbol: str, initial_weight: float = None, risk_limit: float = 0.3) -> bool:\n        \"\"\"Add new asset to portfolio with intelligent allocation\"\"\"\n        try:\n            if len(self.active_symbols) >= self.max_assets:\n                print(f\"   ‚ö†Ô∏è Portfolio full ({self.max_assets} assets). Consider removing underperforming assets.\")\n                return False\n            \n            if symbol in self.active_symbols:\n                print(f\"   ‚ö†Ô∏è {symbol} already in portfolio\")\n                return False\n            \n            # Calculate optimal initial weight\n            if initial_weight is None:\n                initial_weight = self._calculate_optimal_weight(symbol, risk_limit)\n            \n            # Create allocation\n            allocation = AssetAllocation(\n                symbol=symbol,\n                target_weight=initial_weight,\n                current_weight=0.0,\n                risk_score=0.5,\n                momentum_score=0.0,\n                confidence=0.6\n            )\n            \n            self.asset_allocations[symbol] = allocation\n            self.active_symbols.add(symbol)\n            \n            # Rebalance portfolio to accommodate new asset\n            await self._rebalance_portfolio()\n            \n            print(f\"   ‚úÖ Added {symbol} to portfolio - Weight: {initial_weight:.1%}, Risk Limit: {risk_limit:.1%}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error adding asset {symbol}: {e}\")\n            return False\n    \n    async def remove_asset(self, symbol: str, reason: str = \"Manual removal\") -> bool:\n        \"\"\"Remove asset from portfolio\"\"\"\n        try:\n            if symbol not in self.active_symbols:\n                print(f\"   ‚ö†Ô∏è {symbol} not in portfolio\")\n                return False\n            \n            # Record removal\n            self.rebalance_history.append({\n                'action': 'remove_asset',\n                'symbol': symbol,\n                'reason': reason,\n                'timestamp': datetime.now(),\n                'old_weight': self.asset_allocations[symbol].current_weight\n            })\n            \n            # Remove from tracking\n            del self.asset_allocations[symbol]\n            self.active_symbols.remove(symbol)\n            if symbol in self.position_sizes:\n                del self.position_sizes[symbol]\n            \n            # Redistribute weights\n            await self._rebalance_portfolio()\n            \n            print(f\"   ‚úÖ Removed {symbol} from portfolio - Reason: {reason}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error removing asset {symbol}: {e}\")\n            return False\n    \n    def _calculate_optimal_weight(self, symbol: str, risk_limit: float) -> float:\n        \"\"\"Calculate optimal weight for new asset\"\"\"\n        try:\n            # Base weight: equal distribution\n            num_active = len(self.active_symbols)\n            if num_active == 0:\n                return min(0.5, risk_limit)  # First asset gets 50% or risk limit\n            \n            # Calculate available weight (assume current assets need rebalancing)\n            available_weight = 1.0 / (num_active + 1)  # Equal distribution\n            \n            # Apply risk limit\n            optimal_weight = min(available_weight, risk_limit)\n            \n            return max(0.05, optimal_weight)  # Minimum 5% allocation\n            \n        except Exception as e:\n            logger.error(f\"Optimal weight calculation error: {e}\")\n            return 0.1  # Default 10%\n    \n    async def update_market_data(self, symbol: str, market_data: Dict):\n        \"\"\"Update market data for asset and recalculate metrics\"\"\"\n        try:\n            if symbol not in self.active_symbols:\n                return\n            \n            allocation = self.asset_allocations[symbol]\n            \n            # Update momentum score\n            prices = market_data.get('prices', [])\n            if len(prices) >= 10:\n                recent_return = (prices[-1] - prices[-10]) / prices[-10]\n                allocation.momentum_score = recent_return\n            \n            # Update risk score based on volatility\n            if len(prices) >= 20:\n                returns = [(prices[i] - prices[i-1]) / prices[i-1] for i in range(1, len(prices))]\n                volatility = np.std(returns)\n                allocation.risk_score = min(1.0, volatility * 10)  # Normalize volatility\n            \n            # Update confidence based on signal strength\n            signal_strength = market_data.get('signal_strength', 0.5)\n            allocation.confidence = signal_strength\n            allocation.last_updated = datetime.now()\n            \n            # Check if rebalancing is needed\n            if self._needs_rebalancing():\n                await self._rebalance_portfolio()\n                \n        except Exception as e:\n            logger.error(f\"Market data update error for {symbol}: {e}\")\n    \n    def _needs_rebalancing(self) -> bool:\n        \"\"\"Check if portfolio needs rebalancing\"\"\"\n        try:\n            for symbol, allocation in self.asset_allocations.items():\n                weight_deviation = abs(allocation.current_weight - allocation.target_weight)\n                if weight_deviation > 0.1:  # 10% deviation threshold\n                    return True\n            \n            # Check for high correlations\n            high_correlation_count = sum(1 for corr in self.correlation_matrix.values() \n                                       if abs(corr) > self.max_correlation)\n            if high_correlation_count > len(self.active_symbols) // 2:\n                return True\n            \n            return False\n            \n        except Exception as e:\n            logger.error(f\"Rebalancing check error: {e}\")\n            return False\n    \n    async def _rebalance_portfolio(self):\n        \"\"\"Intelligent portfolio rebalancing\"\"\"\n        try:\n            if not self.active_symbols:\n                return\n            \n            print(f\"   üîÑ Rebalancing portfolio across {len(self.active_symbols)} assets...\")\n            \n            # Get optimization recommendations\n            new_weights = await self.allocation_optimizer.optimize_weights(\n                self.asset_allocations,\n                self.correlation_matrix,\n                self.asset_performance\n            )\n            \n            # Update target weights\n            total_adjustment = 0\n            for symbol, new_weight in new_weights.items():\n                if symbol in self.asset_allocations:\n                    old_weight = self.asset_allocations[symbol].target_weight\n                    self.asset_allocations[symbol].target_weight = new_weight\n                    adjustment = abs(new_weight - old_weight)\n                    total_adjustment += adjustment\n            \n            # Record rebalancing\n            self.rebalance_history.append({\n                'timestamp': datetime.now(),\n                'weights': new_weights.copy(),\n                'total_adjustment': total_adjustment,\n                'num_assets': len(self.active_symbols)\n            })\n            \n            print(f\"   ‚úÖ Portfolio rebalanced - Total adjustment: {total_adjustment:.1%}\")\n            \n        except Exception as e:\n            logger.error(f\"Portfolio rebalancing error: {e}\")\n    \n    def calculate_portfolio_metrics(self) -> PortfolioMetrics:\n        \"\"\"Calculate comprehensive portfolio metrics\"\"\"\n        try:\n            # Calculate total portfolio value\n            total_value = sum(self.position_sizes.get(symbol, 0) * \n                            self.asset_allocations[symbol].current_weight \n                            for symbol in self.active_symbols)\n            \n            # Calculate daily P&L\n            daily_pnl = total_value - self.current_capital if total_value > 0 else 0\n            \n            # Calculate win rate (placeholder)\n            win_rate = 0.75  # Would calculate from trade history\n            \n            # Calculate Sharpe ratio\n            if len(self.daily_returns) > 30:\n                returns_array = np.array(self.daily_returns)\n                sharpe_ratio = np.mean(returns_array) / (np.std(returns_array) + 1e-8) * np.sqrt(252)\n            else:\n                sharpe_ratio = 0.0\n            \n            # Calculate max drawdown\n            max_drawdown = self._calculate_max_drawdown()\n            \n            # Calculate volatility\n            volatility = np.std(self.daily_returns) * np.sqrt(252) if len(self.daily_returns) > 10 else 0.0\n            \n            return PortfolioMetrics(\n                total_value=total_value,\n                daily_pnl=daily_pnl,\n                win_rate=win_rate,\n                sharpe_ratio=sharpe_ratio,\n                max_drawdown=max_drawdown,\n                volatility=volatility,\n                beta=0.8,  # Placeholder\n                alpha=0.05  # Placeholder\n            )\n            \n        except Exception as e:\n            logger.error(f\"Portfolio metrics calculation error: {e}\")\n            return PortfolioMetrics(0, 0, 0, 0, 0, 0, 0, 0)\n    \n    def _calculate_max_drawdown(self) -> float:\n        \"\"\"Calculate maximum drawdown from portfolio history\"\"\"\n        try:\n            if len(self.portfolio_history) < 2:\n                return 0.0\n            \n            values = [entry['total_value'] for entry in self.portfolio_history]\n            peak = values[0]\n            max_dd = 0.0\n            \n            for value in values[1:]:\n                if value > peak:\n                    peak = value\n                else:\n                    drawdown = (peak - value) / peak\n                    max_dd = max(max_dd, drawdown)\n            \n            return max_dd\n            \n        except Exception as e:\n            logger.error(f\"Max drawdown calculation error: {e}\")\n            return 0.0\n    \n    async def get_cross_asset_signals(self) -> Dict[str, Dict]:\n        \"\"\"Generate cross-asset trading signals\"\"\"\n        signals = {}\n        \n        try:\n            for symbol in self.active_symbols:\n                allocation = self.asset_allocations[symbol]\n                \n                # Combine momentum, risk, and confidence\n                signal_strength = (\n                    allocation.momentum_score * 0.4 +\n                    (1 - allocation.risk_score) * 0.3 +\n                    allocation.confidence * 0.3\n                )\n                \n                # Generate signal\n                if signal_strength > 0.3:\n                    direction = 'BUY'\n                    strength = min(1.0, signal_strength)\n                elif signal_strength < -0.3:\n                    direction = 'SELL'\n                    strength = min(1.0, abs(signal_strength))\n                else:\n                    direction = 'HOLD'\n                    strength = 0.0\n                \n                signals[symbol] = {\n                    'direction': direction,\n                    'strength': strength,\n                    'confidence': allocation.confidence,\n                    'allocation_weight': allocation.target_weight,\n                    'risk_adjusted': True\n                }\n            \n            print(f\"   üìä Generated cross-asset signals for {len(signals)} assets\")\n            return signals\n            \n        except Exception as e:\n            logger.error(f\"Cross-asset signal generation error: {e}\")\n            return {}\n    \n    def get_portfolio_status(self) -> Dict:\n        \"\"\"Get comprehensive portfolio status\"\"\"\n        try:\n            metrics = self.calculate_portfolio_metrics()\n            \n            # Calculate diversification metrics\n            diversification = self._calculate_diversification_score()\n            \n            # Risk analysis\n            portfolio_risk = self.risk_analyzer.calculate_portfolio_risk(self.asset_allocations)\n            \n            status = {\n                'total_value': metrics.total_value,\n                'daily_pnl': metrics.daily_pnl,\n                'daily_return': metrics.daily_pnl / self.current_capital,\n                'win_rate': metrics.win_rate,\n                'sharpe_ratio': metrics.sharpe_ratio,\n                'max_drawdown': metrics.max_drawdown,\n                'portfolio_risk': portfolio_risk,\n                'diversification_score': diversification,\n                'num_assets': len(self.active_symbols),\n                'active_assets': list(self.active_symbols),\n                'last_rebalance': self.rebalance_history[-1]['timestamp'] if self.rebalance_history else None\n            }\n            \n            return status\n            \n        except Exception as e:\n            logger.error(f\"Portfolio status error: {e}\")\n            return {}\n    \n    def _calculate_diversification_score(self) -> float:\n        \"\"\"Calculate portfolio diversification score (0-1)\"\"\"\n        try:\n            if len(self.active_symbols) <= 1:\n                return 0.0\n            \n            # Weight distribution score\n            weights = [allocation.target_weight for allocation in self.asset_allocations.values()]\n            weight_entropy = -sum(w * np.log(w + 1e-8) for w in weights if w > 0)\n            max_entropy = np.log(len(weights))\n            weight_score = weight_entropy / max_entropy if max_entropy > 0 else 0\n            \n            # Correlation penalty\n            avg_correlation = np.mean([abs(corr) for corr in self.correlation_matrix.values()])\n            correlation_score = 1 - avg_correlation\n            \n            # Risk distribution score\n            risk_scores = [allocation.risk_score for allocation in self.asset_allocations.values()]\n            risk_diversity = 1 - np.std(risk_scores) if len(risk_scores) > 1 else 0\n            \n            # Combined diversification score\n            diversification = (weight_score * 0.4 + correlation_score * 0.4 + risk_diversity * 0.2)\n            self.diversification_score = diversification\n            \n            return diversification\n            \n        except Exception as e:\n            logger.error(f\"Diversification calculation error: {e}\")\n            return 0.0\n    \n    async def optimize_portfolio(self, market_conditions: Dict) -> Dict:\n        \"\"\"Comprehensive portfolio optimization\"\"\"\n        try:\n            optimization_results = {}\n            \n            # 1. Asset allocation optimization\n            allocation_results = await self.allocation_optimizer.optimize_allocation(\n                self.asset_allocations,\n                market_conditions,\n                self.target_metrics\n            )\n            optimization_results['allocation'] = allocation_results\n            \n            # 2. Risk optimization\n            risk_results = await self.risk_analyzer.optimize_risk_distribution(\n                self.asset_allocations,\n                self.correlation_matrix\n            )\n            optimization_results['risk'] = risk_results\n            \n            # 3. Rebalancing optimization\n            rebalance_results = await self.rebalancing_engine.optimize_rebalancing_schedule(\n                self.asset_allocations,\n                self.portfolio_history\n            )\n            optimization_results['rebalancing'] = rebalance_results\n            \n            print(f\"   ‚öôÔ∏è Portfolio optimization complete - {len(optimization_results)} areas optimized\")\n            return optimization_results\n            \n        except Exception as e:\n            logger.error(f\"Portfolio optimization error: {e}\")\n            return {}\n    \n    @property\n    def target_metrics(self) -> Dict:\n        \"\"\"Target portfolio metrics\"\"\"\n        return {\n            'win_rate': 0.90,\n            'max_drawdown': 0.05,\n            'sharpe_ratio': 2.5,\n            'diversification': 0.8,\n            'correlation_limit': 0.7\n        }\n\nclass AllocationOptimizer:\n    \"\"\"üéØ Intelligent asset allocation optimizer\"\"\"\n    \n    def __init__(self):\n        self.optimization_history = deque(maxlen=100)\n        self.allocation_models = {\n            'momentum': MomentumAllocationModel(),\n            'mean_reversion': MeanReversionAllocationModel(),\n            'risk_parity': RiskParityModel(),\n            'black_litterman': BlackLittermanModel()\n        }\n    \n    async def optimize_allocation(self, asset_allocations: Dict, market_conditions: Dict, targets: Dict) -> Dict:\n        \"\"\"Optimize asset allocation using multiple models\"\"\"\n        try:\n            optimization_signals = {}\n            \n            # Get signals from each model\n            for model_name, model in self.allocation_models.items():\n                try:\n                    model_signals = await model.generate_allocation_signals(\n                        asset_allocations, market_conditions\n                    )\n                    optimization_signals[model_name] = model_signals\n                except Exception as e:\n                    logger.error(f\"Error in {model_name} model: {e}\")\n            \n            # Combine model signals\n            combined_allocation = self._combine_model_signals(optimization_signals, targets)\n            \n            return combined_allocation\n            \n        except Exception as e:\n            logger.error(f\"Allocation optimization error: {e}\")\n            return {}\n    \n    def _combine_model_signals(self, signals: Dict, targets: Dict) -> Dict:\n        \"\"\"Combine signals from different allocation models\"\"\"\n        try:\n            symbols = set()\n            for model_signals in signals.values():\n                symbols.update(model_signals.keys())\n            \n            combined = {}\n            \n            for symbol in symbols:\n                # Weighted combination of model signals\n                momentum_weight = signals.get('momentum', {}).get(symbol, 0) * 0.3\n                mean_rev_weight = signals.get('mean_reversion', {}).get(symbol, 0) * 0.2\n                risk_parity_weight = signals.get('risk_parity', {}).get(symbol, 0) * 0.3\n                black_lit_weight = signals.get('black_litterman', {}).get(symbol, 0) * 0.2\n                \n                combined_weight = momentum_weight + mean_rev_weight + risk_parity_weight + black_lit_weight\n                combined[symbol] = max(0.05, min(0.4, combined_weight))  # Clamp between 5-40%\n            \n            # Normalize weights\n            total_weight = sum(combined.values())\n            if total_weight > 0:\n                for symbol in combined:\n                    combined[symbol] /= total_weight\n            \n            return combined\n            \n        except Exception as e:\n            logger.error(f\"Signal combination error: {e}\")\n            return {}\n\nclass MomentumAllocationModel:\n    \"\"\"Momentum-based allocation model\"\"\"\n    \n    async def generate_allocation_signals(self, allocations: Dict, market: Dict) -> Dict:\n        \"\"\"Generate momentum-based allocation signals\"\"\"\n        signals = {}\n        \n        try:\n            # Sort by momentum score\n            sorted_assets = sorted(\n                allocations.items(),\n                key=lambda x: x[1].momentum_score,\n                reverse=True\n            )\n            \n            # Allocate more to high momentum assets\n            total_symbols = len(sorted_assets)\n            for i, (symbol, allocation) in enumerate(sorted_assets):\n                # Higher weight for higher momentum\n                momentum_factor = (total_symbols - i) / total_symbols\n                base_weight = 1.0 / total_symbols\n                signals[symbol] = base_weight * (1 + momentum_factor * 0.5)\n            \n        except Exception as e:\n            logger.error(f\"Momentum allocation error: {e}\")\n        \n        return signals\n\nclass MeanReversionAllocationModel:\n    \"\"\"Mean reversion allocation model\"\"\"\n    \n    async def generate_allocation_signals(self, allocations: Dict, market: Dict) -> Dict:\n        \"\"\"Generate mean reversion allocation signals\"\"\"\n        signals = {}\n        \n        try:\n            # Sort by inverse momentum (contrarian approach)\n            sorted_assets = sorted(\n                allocations.items(),\n                key=lambda x: x[1].momentum_score\n            )\n            \n            # Allocate more to oversold assets\n            total_symbols = len(sorted_assets)\n            for i, (symbol, allocation) in enumerate(sorted_assets):\n                # Higher weight for lower momentum (oversold)\n                reversion_factor = (total_symbols - i) / total_symbols\n                base_weight = 1.0 / total_symbols\n                signals[symbol] = base_weight * (1 + reversion_factor * 0.3)\n            \n        except Exception as e:\n            logger.error(f\"Mean reversion allocation error: {e}\")\n        \n        return signals\n\nclass RiskParityModel:\n    \"\"\"Risk parity allocation model\"\"\"\n    \n    async def generate_allocation_signals(self, allocations: Dict, market: Dict) -> Dict:\n        \"\"\"Generate risk parity allocation signals\"\"\"\n        signals = {}\n        \n        try:\n            # Calculate inverse risk weights\n            total_inverse_risk = sum(1 / (allocation.risk_score + 0.01) \n                                   for allocation in allocations.values())\n            \n            for symbol, allocation in allocations.items():\n                # Weight inversely proportional to risk\n                inverse_risk = 1 / (allocation.risk_score + 0.01)\n                signals[symbol] = inverse_risk / total_inverse_risk\n            \n        except Exception as e:\n            logger.error(f\"Risk parity allocation error: {e}\")\n        \n        return signals\n\nclass BlackLittermanModel:\n    \"\"\"Black-Litterman allocation model\"\"\"\n    \n    async def generate_allocation_signals(self, allocations: Dict, market: Dict) -> Dict:\n        \"\"\"Generate Black-Litterman allocation signals\"\"\"\n        signals = {}\n        \n        try:\n            # Simplified Black-Litterman implementation\n            # Combine market cap weights with views\n            \n            num_assets = len(allocations)\n            if num_assets == 0:\n                return signals\n            \n            # Start with equal weights\n            base_weight = 1.0 / num_assets\n            \n            for symbol, allocation in allocations.items():\n                # Adjust based on confidence in views\n                confidence_adjustment = allocation.confidence - 0.5  # Center around 0\n                momentum_adjustment = allocation.momentum_score * 0.2\n                \n                adjusted_weight = base_weight * (1 + confidence_adjustment + momentum_adjustment)\n                signals[symbol] = max(0.02, min(0.5, adjusted_weight))\n            \n        except Exception as e:\n            logger.error(f\"Black-Litterman allocation error: {e}\")\n        \n        return signals\n\nclass PortfolioRiskAnalyzer:\n    \"\"\"üìà Portfolio risk analysis and management\"\"\"\n    \n    def __init__(self):\n        self.risk_models = {\n            'var': ValueAtRiskModel(),\n            'cvar': ConditionalVaRModel(),\n            'correlation': CorrelationRiskModel(),\n            'tail_risk': TailRiskModel()\n        }\n    \n    def calculate_portfolio_risk(self, allocations: Dict) -> float:\n        \"\"\"Calculate overall portfolio risk score\"\"\"\n        try:\n            if not allocations:\n                return 0.0\n            \n            # Weighted average of individual asset risks\n            total_risk = 0.0\n            total_weight = 0.0\n            \n            for allocation in allocations.values():\n                weight = allocation.current_weight\n                risk = allocation.risk_score\n                total_risk += weight * risk\n                total_weight += weight\n            \n            portfolio_risk = total_risk / total_weight if total_weight > 0 else 0.0\n            \n            # Apply correlation penalty\n            correlation_penalty = self._calculate_correlation_penalty(allocations)\n            adjusted_risk = portfolio_risk * (1 + correlation_penalty)\n            \n            return min(1.0, adjusted_risk)\n            \n        except Exception as e:\n            logger.error(f\"Portfolio risk calculation error: {e}\")\n            return 0.5\n    \n    def _calculate_correlation_penalty(self, allocations: Dict) -> float:\n        \"\"\"Calculate penalty for high correlations\"\"\"\n        try:\n            if len(allocations) <= 1:\n                return 0.0\n            \n            # Estimate correlations (simplified)\n            symbols = list(allocations.keys())\n            correlations = []\n            \n            for i, symbol1 in enumerate(symbols):\n                for symbol2 in symbols[i+1:]:\n                    # Simplified correlation estimate based on momentum similarity\n                    momentum1 = allocations[symbol1].momentum_score\n                    momentum2 = allocations[symbol2].momentum_score\n                    \n                    # Correlation proxy\n                    correlation = abs(momentum1 - momentum2)\n                    correlations.append(correlation)\n            \n            avg_correlation = np.mean(correlations) if correlations else 0.0\n            \n            # Penalty increases with correlation\n            penalty = max(0.0, (avg_correlation - 0.3) * 0.5)\n            \n            return penalty\n            \n        except Exception as e:\n            logger.error(f\"Correlation penalty calculation error: {e}\")\n            return 0.0\n    \n    async def optimize_risk_distribution(self, allocations: Dict, correlation_matrix: Dict) -> Dict:\n        \"\"\"Optimize risk distribution across assets\"\"\"\n        try:\n            risk_adjustments = {}\n            \n            for symbol, allocation in allocations.items():\n                # Calculate risk-adjusted weight\n                current_weight = allocation.target_weight\n                risk_score = allocation.risk_score\n                \n                # Adjust for risk\n                if risk_score > 0.7:  # High risk\n                    risk_adjustment = -0.1  # Reduce allocation\n                elif risk_score < 0.3:  # Low risk\n                    risk_adjustment = 0.05  # Increase allocation\n                else:\n                    risk_adjustment = 0.0\n                \n                new_weight = max(0.05, min(0.4, current_weight + risk_adjustment))\n                risk_adjustments[symbol] = new_weight\n            \n            return risk_adjustments\n            \n        except Exception as e:\n            logger.error(f\"Risk distribution optimization error: {e}\")\n            return {}\n\nclass ValueAtRiskModel:\n    \"\"\"Value at Risk calculation\"\"\"\n    \n    def calculate_var(self, returns: List[float], confidence: float = 0.95) -> float:\n        \"\"\"Calculate portfolio Value at Risk\"\"\"\n        try:\n            if len(returns) < 10:\n                return 0.0\n            \n            # Calculate percentile\n            return np.percentile(returns, (1 - confidence) * 100)\n            \n        except Exception as e:\n            logger.error(f\"VaR calculation error: {e}\")\n            return 0.0\n\nclass ConditionalVaRModel:\n    \"\"\"Conditional Value at Risk (Expected Shortfall)\"\"\"\n    \n    def calculate_cvar(self, returns: List[float], confidence: float = 0.95) -> float:\n        \"\"\"Calculate Conditional VaR\"\"\"\n        try:\n            if len(returns) < 10:\n                return 0.0\n            \n            var_threshold = np.percentile(returns, (1 - confidence) * 100)\n            tail_returns = [r for r in returns if r <= var_threshold]\n            \n            return np.mean(tail_returns) if tail_returns else 0.0\n            \n        except Exception as e:\n            logger.error(f\"CVaR calculation error: {e}\")\n            return 0.0\n\nclass CorrelationRiskModel:\n    \"\"\"Correlation-based risk model\"\"\"\n    \n    def calculate_correlation_risk(self, correlations: Dict, weights: Dict) -> float:\n        \"\"\"Calculate risk from asset correlations\"\"\"\n        try:\n            if len(weights) <= 1:\n                return 0.0\n            \n            # Simplified correlation risk\n            symbols = list(weights.keys())\n            total_correlation_risk = 0.0\n            \n            for i, symbol1 in enumerate(symbols):\n                for symbol2 in symbols[i+1:]:\n                    correlation = correlations.get((symbol1, symbol2), 0.0)\n                    weight_product = weights[symbol1] * weights[symbol2]\n                    correlation_contribution = abs(correlation) * weight_product\n                    total_correlation_risk += correlation_contribution\n            \n            return total_correlation_risk\n            \n        except Exception as e:\n            logger.error(f\"Correlation risk calculation error: {e}\")\n            return 0.0\n\nclass TailRiskModel:\n    \"\"\"Tail risk analysis model\"\"\"\n    \n    def calculate_tail_risk(self, returns: List[float]) -> float:\n        \"\"\"Calculate tail risk metrics\"\"\"\n        try:\n            if len(returns) < 20:\n                return 0.0\n            \n            # Calculate skewness and kurtosis\n            mean_return = np.mean(returns)\n            std_return = np.std(returns)\n            \n            if std_return == 0:\n                return 0.0\n            \n            # Skewness (asymmetry)\n            skewness = np.mean([(r - mean_return)**3 for r in returns]) / (std_return**3)\n            \n            # Kurtosis (tail heaviness)\n            kurtosis = np.mean([(r - mean_return)**4 for r in returns]) / (std_return**4)\n            \n            # Tail risk score\n            tail_risk = abs(skewness) * 0.5 + max(0, kurtosis - 3) * 0.5\n            \n            return min(1.0, tail_risk / 2)  # Normalize\n            \n        except Exception as e:\n            logger.error(f\"Tail risk calculation error: {e}\")\n            return 0.0\n\nclass SmartRebalancingEngine:\n    \"\"\"üîÑ Intelligent portfolio rebalancing\"\"\"\n    \n    def __init__(self):\n        self.rebalancing_rules = {\n            'threshold': 0.05,  # 5% deviation triggers rebalancing\n            'min_interval': timedelta(hours=6),  # Minimum time between rebalances\n            'volatility_adjustment': True,\n            'transaction_cost_optimization': True\n        }\n        self.last_rebalance = datetime.now()\n    \n    async def optimize_rebalancing_schedule(self, allocations: Dict, history: deque) -> Dict:\n        \"\"\"Optimize when and how to rebalance\"\"\"\n        try:\n            current_time = datetime.now()\n            time_since_last = current_time - self.last_rebalance\n            \n            # Check if rebalancing is needed\n            rebalance_needed = self._assess_rebalancing_need(allocations)\n            \n            if not rebalance_needed or time_since_last < self.rebalancing_rules['min_interval']:\n                return {'rebalance_recommended': False, 'reason': 'Not needed or too soon'}\n            \n            # Calculate optimal rebalancing strategy\n            rebalancing_plan = self._create_rebalancing_plan(allocations)\n            \n            return {\n                'rebalance_recommended': True,\n                'plan': rebalancing_plan,\n                'expected_benefit': self._estimate_rebalancing_benefit(rebalancing_plan),\n                'execution_priority': 'medium'\n            }\n            \n        except Exception as e:\n            logger.error(f\"Rebalancing optimization error: {e}\")\n            return {'rebalance_recommended': False, 'reason': 'Error in analysis'}\n    \n    def _assess_rebalancing_need(self, allocations: Dict) -> bool:\n        \"\"\"Assess if portfolio needs rebalancing\"\"\"\n        try:\n            for allocation in allocations.values():\n                deviation = abs(allocation.current_weight - allocation.target_weight)\n                if deviation > self.rebalancing_rules['threshold']:\n                    return True\n            return False\n        except:\n            return False\n    \n    def _create_rebalancing_plan(self, allocations: Dict) -> Dict:\n        \"\"\"Create detailed rebalancing execution plan\"\"\"\n        plan = {\n            'adjustments': {},\n            'execution_order': [],\n            'total_trades': 0\n        }\n        \n        try:\n            for symbol, allocation in allocations.items():\n                deviation = allocation.target_weight - allocation.current_weight\n                if abs(deviation) > 0.01:  # 1% minimum adjustment\n                    plan['adjustments'][symbol] = {\n                        'current': allocation.current_weight,\n                        'target': allocation.target_weight,\n                        'adjustment': deviation,\n                        'priority': abs(deviation)  # Larger deviations get higher priority\n                    }\n            \n            # Sort by priority\n            plan['execution_order'] = sorted(\n                plan['adjustments'].keys(),\n                key=lambda x: plan['adjustments'][x]['priority'],\n                reverse=True\n            )\n            \n            plan['total_trades'] = len(plan['adjustments'])\n            \n        except Exception as e:\n            logger.error(f\"Rebalancing plan creation error: {e}\")\n        \n        return plan\n    \n    def _estimate_rebalancing_benefit(self, plan: Dict) -> float:\n        \"\"\"Estimate expected benefit from rebalancing\"\"\"\n        try:\n            if not plan.get('adjustments'):\n                return 0.0\n            \n            # Simple benefit estimation based on deviation size\n            total_deviation = sum(abs(adj['adjustment']) for adj in plan['adjustments'].values())\n            estimated_benefit = min(0.02, total_deviation * 0.1)  # Max 2% benefit\n            \n            return estimated_benefit\n            \n        except Exception as e:\n            logger.error(f\"Rebalancing benefit estimation error: {e}\")\n            return 0.0\n\n# Global portfolio manager\nportfolio_manager = MultiAssetPortfolioManager()\n\nprint(\"üè¶ Multi-Asset Portfolio Manager ready!\")\nprint(\"   üìä Features: Smart allocation, risk analysis, auto-rebalancing\")\nprint(\"   üéØ Target: 90% win rate with optimal diversification\")
